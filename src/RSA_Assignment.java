import java.math.BigInteger;

public class RSA_Assignment {

	public static void main (String args[]){
		
		/** keygen **/
		// setting 2 prime numbers
		BigInteger p = new BigInteger("531872289054204184185084734375133399408303613982130856645299464930952178606045848877129147820387996428175564228204785846141207532462936339834139412401975338705794646595487324365194792822189473092273993580587964571659678084484152603881094176995594813302284232006001752128168901293560051833646881436219");
		BigInteger q = new BigInteger("319705304701141539155720137200974664666792526059405792539680974929469783512821793995613718943171723765238853752439032835985158829038528214925658918372196742089464683960239919950882355844766055365179937610326127675178857306260955550407044463370239890187189750909036833976197804646589380690779463976173");

		// multiplying to find n for part of public key
		BigInteger n = p.multiply(q);
		
		// martin's public key
		BigInteger mn = new BigInteger("239255299284384349304725149856552492038598445886956658797340414572081315025316855599003056773010145489861807217942474066769254994889937350554812114599199747011822931003470188469755565575428252755498450043694308433269873821720504733262583005940196298951811543171416951549542705533417999736765774452030314635913103516225119401185982005668156650192848448135779911780427770251154346413709247810959979685820122190878080140819951259653464493002404315741219936122712441337048287859676453307655235582246940129654549936418104588280142515645148689690033053995534499764950491215574658031050257809925263610106291");
		BigInteger me = new BigInteger("51831672085074814178680269722598016921936838558306727005991561731670505910386509866184899294113023750765710594543251856658239666016521056714215727353889825219309912019100396570607753922542886645209401533085461587994461683838141339926725638136349726690307472237142348752101995510115124409635193574780938087738364459858781987481597603026016849697794677");

		// printing out for testing
		// System.out.println("n is "+n);

		// finding p-1 and q-1
		BigInteger p1 = p.subtract(BigInteger.ONE);
		BigInteger q1 = q.subtract(BigInteger.ONE);

		// multiplying to find phi
		BigInteger phi = p1.multiply(q1);

		// e greater than 70000
		BigInteger e = new BigInteger("70000");
		
		// find e coprime with phi
		while (!(e.gcd(phi).equals(BigInteger.ONE))){
			e = e.add(BigInteger.ONE);
		}
		
		// find d so ed is congruent with 1 (mod phi)
		BigInteger d;
		d = e.modInverse(phi);
		
		
		/** encryption **/
		// message to be encrypted
		BigInteger M = new BigInteger("104101108108111032116104105115032105115032115104097114111110032122104101110103032105100032105115032115053050122104101110103032105032104111112101032116104105115032119111114107115032116104097110107115");
		
		// ciphertext
		BigInteger C;
		C = M.modPow(me, mn); // encrypt using martin's keys
		System.out.println("encrypted message: " + C);
		
		/** decryption **/
		// message to be decrypted
		BigInteger D;
		
		// received message
		BigInteger RM = new BigInteger("98490576016520784722885193571463179768201860759389009665397641251645025731229648338687148880964234511602373080507264506850517924881920098176152560902177773369995438755380754801819087734315210611663244414630727144836702539845496047431795600586580282802373264189189280475457198140175509749106746787216224893319293217455287380169220060018867795147851263075282742905747304680298212050841384996200136878376226843443101680436510222295900647376116142252167923435659121562784511154699044478353613821528467156193691433507346531767210964142361376423558973125434488542166639249524984004004150484631920687686614");
		
		// decyrpt using your own private key
		D = RM.modPow(d,n);
		System.out.println("decrypted message: " + D);

	}

}

